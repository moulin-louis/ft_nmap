#include <ft_nmap.h>

#define UDP_PAYLOAD_MAXLEN 528

typedef struct s_udp_phdr {
  uint32_t srcAddr;
  uint32_t dstAddr;
  uint8_t zero;
  uint8_t protocol;
  uint16_t udpLength;
} __attribute__((packed)) UDP_PHdr;

typedef struct s_udp_hdr {
  uint16_t srcPort;
  uint16_t dstPort;
  uint16_t msgLength;
  uint16_t checksum;
} __attribute__((packed)) UDP_Hdr;

typedef struct s_udp_request {
  UDP_PHdr pseudoHeader;
  UDP_Hdr header;
  uint8_t payload[UDP_PAYLOAD_MAXLEN];
} __attribute__((packed)) UDP_Request;

uint32_t udp_send_probe(const NMAP_UltraScan* us, t_port* port, struct in_addr ip_dst, struct in_addr ip_src) {
  static const char* specialPortsPayloads[] = {
    [7] = "\x0d\x0a\x0d\x0a",
    [53] = "\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00",
    [80] = "\x0d\x31\x32\x33\x34\x35\x36\x37\x38\x51\x39\x39\x39\x00",
    [111] = "\x72\xfe\x1d\x13\x00\x00\x00\x00\x00\x00\x00\x02\x00\x01\x86\xa0"
            "\x00\x01\x97\x7c\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
            "\x00\x00\x00\x00\x00\x00\x00\x00",
    [123] = "\xe3\x00\x04\xfa\x00\x01\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00"
            "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
            "\x00\x00\x00\x00\x00\x00\x00\x00\xc5\x4f\x23\x4b\x71\xb1\x52\xf3",
    [137] = "\x80\xf0\x00\x10\x00\x01\x00\x00\x00\x00\x00\x00\x20\x43\x4b\x41"
            "\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
            "\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x00\x00\x21"
            "\x00\x01",
    [161] = "\x30\x3a\x02\x01\x03\x30\x0f\x02\x02\x4a\x69\x02\x03\x00\xff\xe3"
            "\x04\x01\x04\x02\x01\x03\x04\x10\x30\x0e\x04\x00\x02\x01\x00\x02"
            "\x01\x00\x04\x00\x04\x00\x04\x00\x30\x12\x04\x00\x04\x00\xa0\x0c"
            "\x02\x02\x37\xf0\x02\x01\x00\x02\x01\x00\x30\x00",
    [177] = "\x00\x01\x00\x02\x00\x01\x00",
    [389] = "\x30\x84\x00\x00\x00\x2d\x02\x01\x07\x63\x84\x00\x00\x00\x24\x04"
            "\x00\x0a\x01\x00\x0a\x01\x00\x02\x01\x00\x02\x01\x64\x01\x01\x00"
            "\x87\x0b\x6f\x62\x6a\x65\x63\x74\x43\x6c\x61\x73\x73\x30\x84\x00"
            "\x00\x00\x00",
    [427] = "\x02\x01\x00\x00\x36\x20\x00\x00\x00\x00\x00\x01\x00\x02\x65\x6e"
            "\x00\x00\x00\x15\x73\x65\x72\x76\x69\x63\x65\x3a\x73\x65\x72\x76"
            "\x69\x63\x65\x2d\x61\x67\x65\x6e\x74\x00\x07\x64\x65\x66\x61\x75"
            "\x6c\x74\x00\x00\x00\x00",
    [443] = "\x16\xfe\xff\x00\x00\x00\x00\x00\x00\x00\x00\x00\x36\x01\x00\x00"
            "\x2a\x00\x00\x00\x00\x00\x00\x00\x2a\xfe\xfd\x00\x00\x00\x00\x7c"
            "\x77\x40\x1e\x8a\xc8\x22\xa0\xa0\x18\xff\x93\x08\xca\xac\x0a\x64"
            "\x2f\xc9\x22\x64\xbc\x08\xa8\x16\x89\x19\x3f\x00\x00\x00\x02\x00"
            "\x2f\x01\x00",
    [500] = "\x00\x11\x22\x33\x44\x55\x66\x77\x00\x00\x00\x00\x00\x00\x00\x00"
            "\x01\x10\x02\x00\x00\x00\x00\x00\x00\x00\x00\xc0\x00\x00\x00\xa4"
            "\x00\x00\x00\x01\x00\x00\x00\x01\x00\x00\x00\x98\x01\x01\x00\x04"
            "\x03\x00\x00\x24\x01\x01\x00\x00\x80\x01\x00\x05\x80\x02\x00\x02"
            "\x80\x03\x00\x01\x80\x04\x00\x02\x80\x0b\x00\x01\x00\x0c\x00\x04"
            "\x00\x00\x00\x01\x03\x00\x00\x24\x02\x01\x00\x00\x80\x01\x00\x05"
            "\x80\x02\x00\x01\x80\x03\x00\x01\x80\x04\x00\x02\x80\x0b\x00\x01"
            "\x00\x0c\x00\x04\x00\x00\x00\x01\x03\x00\x00\x24\x03\x01\x00\x00"
            "\x80\x01\x00\x01\x80\x02\x00\x02\x80\x03\x00\x01\x80\x04\x00\x02"
            "\x80\x0b\x00\x01\x00\x0c\x00\x04\x00\x00\x00\x01\x00\x00\x00\x24"
            "\x04\x01\x00\x00\x80\x01\x00\x01\x80\x02\x00\x01\x80\x03\x00\x01"
            "\x80\x04\x00\x02\x80\x0b\x00\x01\x00\x0c\x00\x04\x00\x00\x00\x01",
    [520] = "\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
            "\x00\x00\x00\x00\x00\x00\x00\x10",
    [623] = "\x06\x00\xff\x07\x00\x00\x00\x00\x00\x00\x00\x00\x00\x09\x20\x18"
            "\xc8\x81\x00\x38\x8e\x04\xb5",
    [853] = "\x16\xfe\xff\x00\x00\x00\x00\x00\x00\x00\x00\x00\x36\x01\x00\x00"
            "\x2a\x00\x00\x00\x00\x00\x00\x00\x2a\xfe\xfd\x00\x00\x00\x00\x7c"
            "\x77\x40\x1e\x8a\xc8\x22\xa0\xa0\x18\xff\x93\x08\xca\xac\x0a\x64"
            "\x2f\xc9\x22\x64\xbc\x08\xa8\x16\x89\x19\x3f\x00\x00\x00\x02\x00"
            "\x2f\x01\x00",
  };

  UDP_Request request = {
    .pseudoHeader =
      {
        .srcAddr = ip_src.s_addr,
        .dstAddr = ip_dst.s_addr,
        .protocol = 17,
      },
    .header =
      {
        .srcPort = 57637,
        .dstPort = port->port,
      },
  };
  size_t payloadSize = 0;

  if (port->port <= 853 && specialPortsPayloads[port->port]) {
    payloadSize = strlen(specialPortsPayloads[port->port]);
    memcpy(request.payload, specialPortsPayloads[port->port], payloadSize);
  }
  request.header.msgLength = request.pseudoHeader.udpLength = sizeof(UDP_Hdr) + payloadSize;
  request.header.checksum = checksum((void*)&request, sizeof(UDP_PHdr) + request.header.msgLength);
  sendto(us->sock, ((uint8_t*)&request) + offsetof(UDP_Request, header), request.header.msgLength, 0,
         (void*)(struct sockaddr_in[]){{
           .sin_family = AF_INET,
           .sin_port = htons(port->port),
           .sin_addr = ip_dst,
         }},
         sizeof(struct sockaddr_in));
  return 0;
}

NMAP_PortStatus udp_analysis(const struct iphdr* ip_hdr, const void* ip_payload) {
  if (ip_hdr->protocol == IPPROTO_UDP)
    return OPEN;
  if (ip_hdr->protocol == IPPROTO_ICMP) {
    const struct icmphdr* icmp_hdr = ip_payload;
    if (icmp_hdr->type == 3) {
      if (icmp_hdr->code == 3)
        return CLOSE;
      if (icmp_hdr->code == 1 || icmp_hdr->code == 2 || icmp_hdr->code == 9 || icmp_hdr->code == 10 ||
          icmp_hdr->code == 13)
        return FILTERED;
    }
  }
  return UNKNOWN;
}
